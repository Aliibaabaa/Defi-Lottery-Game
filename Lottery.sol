// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";

contract Lottery is VRFConsumerBaseV2 {
  
  modifier onlyOwner() {
    require(msg.sender == s_owner);
    _;
  }
  struct RequestStatus {
    bool fulfilled;
    bool exists;
  }
  struct LottoNumbers {
      uint256 number1;
      uint256 number2;
      uint256 number3;
      uint256 number4;
      uint256 number5;
      uint256 number6;
  }
  address[] playersList;
  uint256[] generatedNumbers;
  mapping(address => LottoNumbers) public playerLottoNumbers;
  mapping(uint256 => RequestStatus) public s_requests;
  mapping(address => uint256) private balances;
  mapping(address => uint256) public lastRequestId;
  VRFCoordinatorV2Interface COORDINATOR;
  
  uint64 s_subscriptionId;
  uint256[] private requestIds;
  bytes32 keyHash = 0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f; 
  uint32 callbackGasLimit = 2500000; 
  uint16 requestConfirmations = 3;
  uint32 numWords = 6; 
  
  address public s_owner; 
  uint256 public _minimumBet = 10000000000000000;
  bool public winner;
  
    uint256 public draw1;
    uint256 public draw2;
    uint256 public draw3;
    uint256 public draw4;
    uint256 public draw5;
    uint256 public draw6;
  
  constructor(uint64 _subscriptionId) VRFConsumerBaseV2(0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed) {
    COORDINATOR = VRFCoordinatorV2Interface(0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed);
    s_owner = msg.sender;
    s_subscriptionId = _subscriptionId;
  }
  function minimumBet(uint256 _amount) public virtual onlyOwner returns (uint256) {
    return _minimumBet = _amount;
  }
  
  //request random numbers from Chainlink's VRF.
    function requestRandomWords() private onlyOwner returns (uint256 requestId) {
      requestId = COORDINATOR.requestRandomWords(
        keyHash,
        s_subscriptionId,
        requestConfirmations,
        callbackGasLimit,
        numWords
      );
      s_requests[requestId] = RequestStatus({exists: true, fulfilled: false});
      requestIds.push(requestId);
      lastRequestId[msg.sender] = requestId;
      return requestId;
    }
    function ticket(
        uint256 _number1,
        uint256 _number2,
        uint256 _number3,
        uint256 _number4,
        uint256 _number5,
        uint256 _number6
    ) public payable {
        uint256 amount = msg.value;
        balances[address(this)] += amount;
        playerLottoNumbers[msg.sender] = (LottoNumbers({
            number1: _number1,
            number2: _number2,
            number3: _number3,
            number4: _number4,
            number5: _number5,
            number6: _number6
        }));
        playersList.push(msg.sender);
        _transfer(s_owner, amount);
    }
    function play() public {
      requestRandomWords();
      winnerLogic();
    }
    function fulfillRandomWords(uint256 _requestId, uint256[] memory randomNumbers) internal override {
        require(s_requests[_requestId].exists, "request not found");
        s_requests[_requestId].fulfilled = true;
        for (uint i = 0; i < 6; i++) {
            uint256 randomNumber = (randomNumbers[i] % 50) + 1;
            while (isDuplicate(randomNumber, i)) {
                randomNumber = (randomNumbers[0] % 50) + 1;
            }
            generatedNumbers.push(randomNumber);
        }
        draw1 = generatedNumbers[0];
        draw2 = generatedNumbers[1];
        draw3 = generatedNumbers[2];
        draw4 = generatedNumbers[3];
        draw5 = generatedNumbers[4];
        draw6 = generatedNumbers[5];
    }
    function isDuplicate(uint256 randomNumber, uint index) private view returns(bool) {
        for (uint i = 0; i < index; i++) {
            if (generatedNumbers[i] == randomNumber) {
                return true;
            }
        }
        return false;
    }
    //checks whether the player's chosen numbers match the random numbers generated by the Chainlink VRF
    function winnerLogic() internal returns(bool) {
        for (uint256 i = 0; i < playersList.length; i++) {
            if (
                playerLottoNumbers[playersList[i]].number1 == draw1 && 
                playerLottoNumbers[playersList[i]].number2 == draw2 && 
                playerLottoNumbers[playersList[i]].number3 == draw3 &&
                playerLottoNumbers[playersList[i]].number4 == draw4 && 
                playerLottoNumbers[playersList[i]].number5 == draw5 && 
                playerLottoNumbers[playersList[i]].number6 == draw6
                ) {
                _transfer(playersList[i], 0.01 ether);
                winner = true;
                return true;
            }
        }
        return false;
    }
    function _transfer(address to, uint256 amount) internal virtual {
          require(address(this) != address(0), "transfer from the zero address");
          require(to != address(0), "transfer to the zero address");
          require(
              balances[address(this)] >= amount,
              "Not enough token to transfer"
          );
          unchecked {
              balances[address(this)] = address(this).balance - amount;
              (bool success, ) = to.call{value: amount}("");
              require(success, "Failed to withdraw entry fee");
              balances[to] += amount;
          }
    }
    function deposit() public payable virtual {
          require(msg.value > 0, "You don't have enough tokens");
          balances[address(this)] += msg.value;
    }
    function getRequestStatus(uint256 _requestId) external view returns (bool fulfilled, uint256, uint256, uint256, uint256, uint256, uint256) {
        require(s_requests[_requestId].exists, "request not found");
        RequestStatus memory request = s_requests[_requestId];
        return (request.fulfilled, draw1, draw2, draw3, draw4, draw5, draw6);
    }
    function balanceOf(address _address) public view returns (uint256) {
        return balances[_address];
    }
    function withdraw() public onlyOwner {
        (bool success, ) = msg.sender.call{value: address(this).balance}("");
        require(success, "Failed to withdraw balance");
        balances[address(this)] = address(this).balance;
    }
    receive() external payable {
    }
}